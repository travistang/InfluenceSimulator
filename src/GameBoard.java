import java.util.ArrayList;
import java.util.EmptyStackException;
import java.util.HashMap;
import java.util.Map.Entry;
import java.util.Vector;
import java.util.Random;
import java.util.Stack;

public class GameBoard {
	// Node is used here because all the instances of nodes will be contained in GameBoard
	private final ArrayList<Node> nodes;
	private final ArrayList<Integer> largeCells;
	private final int numberOfCells;
	public static final float LARGE_CELL_RATIO = 0.25f;
	//functions related to adjacency matrix
	public int[][] getAdjacencyMatrix()
	{
		int[][] mat = new int[numberOfCells][numberOfCells];
		for(int i = 0; i < numberOfCells; i++)
		{
			Vector<Node> cont = nodes.get(i).getConnections();
			for(Node n : cont)
			{
				if(n == null)
					continue;
				int c = n.id;
				//is undirected graph
				mat[i][c] = 1;
				mat[c][i] = 1;
			}
		}
		return mat;
	}
	// the vector stores references of Node, but the nodes are passed by value of references in methods
	// so get the object 
	public Node getNodeWithId(int id)
	{
		for(int i = 0; i < nodes.size(); i++)
		{
			if(nodes.get(i).id == id)
				return nodes.get(i);
		}
		return null;
	}
	public void connectNodesAccordingToAdjacencyMatrix(int[][] mat)
	{
		//disconnect all nodes first
		for(int i = 0; i < nodes.size(); i++)
		{
			nodes.get(i).disconnectFromAllNodes();
		}
		for(int i = 0; i < mat.length; i++)
		{
			for(int j = 0; j < mat[0].length; j++)
			{
				//TODO: fix this.
				if(mat[i][j] == 1)
//					getNodeWithId(i).connectTo(getNodeWithId(j));
					nodes.get(i).connectTo(nodes.get(j));
			}
		}
	}
	public int getNumberOfNodes()
	{
		return nodes.size();
	}
	//helper function
	private int sumDeg(int[][] mat, int ind)
	{
		int res = 0;
		for(int i = 0; i < mat[0].length; i++)
		{
			res += mat[ind][i];
		}
		return res;
	}
	/**
	 * Generate a random adjacency matrix, so that each node has a degree from 1 to 6
	 * And the graph is not disconnected
	 * Algorithm:
	 * (0. Get a fully-connected graph) 
	 * 1. Generate a spanning tree of the graph
	 * 2. Mark the edges of spanning tree so that they will not be dropped
	 * 3. Generate a random number of edges to drop, ranging from 0 to (2V + 1)
	 * (note: because for a fully connected board each node will have degree of 6,
	 *  	  therefore there are at most 6V/2 = 3V edges in the graph.
	 *  	  Where V is the number of nodes in this graph.
	 *  	  To maintain the spanning tree marked as "un-droppable" so that
	 *  	  the graph will not be disconnected, at most 3V - (number of edges
	 *   	  in the spanning tree) can be dropped. Since there must be (V - 1) edges
	 *   	  in the tree, the maximum number of edges that can be dropped
	 *   	  is 3V - (V - 1) = 2V + 1.
	 *   	  
	 *   	  BUT:
	 *   	  If the number of edges to keep is exactly equals to the number of edges
	 *        in the tree (thus the number of edges to drop is 2V + 1) 
	 *        it would take so long to "randomly" pick the last edges as
	 *        there will be only 1/(2(V+1)) chances to drop the last edge, which is
	 *        very unlikely for a large number of nodes.
	 *        
	 *        Also, it is not so meaningful to not to drop any edges by this method
	 *        therefore the lower bound of the number of edges to drop should be raised.
	 *        
	 *        Eventually this method will drop V/2 to V edges after some experiments)
	 * 4. Randomly select n "droppable" edges from the graph.
	 * 5. Drop the edges by setting the corresponding entries in the matrix to 0.
	 * 6. Return the matrix.   	  
	 * 
	 * Note:
	 * 		This method makes the graph fully connected even if 
	 * 		"connectNodesAccordingToAdjacencyMatrix" is not called.
	 * 
	 * @return a random adjacency matrix generated by the above algorithm
	 */
	public int[][] generateRandomAdjacencyMatrix()
	{
		Random random = new Random();
		//0.
		int[][] mat = generateFullyConnectedAdjacencyMatrix();
		this.connectNodesAccordingToAdjacencyMatrix(mat);
		//1.
		int[] visitedNodes = new int[numberOfCells];
		HashMap<Integer,Integer> undroppables = new HashMap<Integer,Integer>();
		int noVisited = 0;
		//determine the start nodes
		Node node = nodes.get(random.nextInt(numberOfCells));
		//record the last visited position of node
		Stack<Node> stack = new Stack<Node>();
		// depth-first construction of spanning tree
		while(noVisited != numberOfCells)
		{
			boolean isNodeChanged = false;
			for(int i = 0; i < node.getDegree(); i++)
			{
				int ind = node.getConnections().get(i).id;
				// if the node is not visited
				if(visitedNodes[ind] == 0)
				{
					//update number of total visited nodes
					noVisited++;
					//mark visited
					visitedNodes[ind]++;
					//mark ok to proceed
					isNodeChanged = true;
					//mark undroppables
					undroppables.put(node.id, ind);
					//record this node, which may be useful in future
					stack.push(node);
					//update node
					node = node.getConnections().get(i);
					break;
				}
			}
			// that means all connected nodes have been visited
			// in this case the stack will be useful
			if(!isNodeChanged)
			{
				try
				{
					// return to the last node and try another way out
					node = stack.pop();
				}catch(EmptyStackException e)
				{
					// then it comes to a problem: 
					// the fully-connected matrix is not actually fully-connected
					System.out.println("Fail to generate random adjacency matrix");
					return mat;
				}
			}
		}
		//3.
		int edgesToDrop = random.nextInt(numberOfCells/2) + numberOfCells/2;
		//4. & 5.
		for(int i = 0; i < edgesToDrop; i++)
		{
			//draw a node
			int from = random.nextInt(numberOfCells);
			node = nodes.get(from);
			if(node == null)
			{
				System.out.println("here");
			}
			boolean hasEdgeDropped = false;
			//pick an edge to drop
			for(int k = 0; k < node.getConnections().size();k++)
			{
				Node target = node.getConnections().get(k);
				//check if the node is marked
				if(undroppables.containsKey(node.id))
				{
					if(undroppables.get(node.id) != target.id && target.getDegree() > 1)
					{
						// the edge is not marked
						// second check : if target will be disconnected
						// if this edge is dropped
						node.disconnectFrom(target);
						hasEdgeDropped = true;
					}
				}else
				{
					// the node id does not appear in undroppables,
					// but it doesn't mean that the edges can be dropped
					// it just means that the node id is in the value set of the hashmap
					// for if it is not in neither key set nor value set the tree generated
					// is not a spanning tree, thus the algorithm fails
					for(Entry<Integer, Integer> pair : undroppables.entrySet())
					{
						if(pair.getValue() == node.id && pair.getKey() == target.id && target.getDegree() > 1)
						{
							node.disconnectFrom(target);
							hasEdgeDropped = true;
							break;
						}
					}
				}
				
			}
			//no edge has dropped
			if(!hasEdgeDropped)
			{
				//draw again
				i--;
			}
		}
		//6.
		return mat;
	}
	
	
	
	/* this method does not give an adjacency with all entries set to 1
	 * instead it connects to the adjacent nodes according to the id-coordinate mapping rule, 
	 * which is specified in the comments above the function constructIDCoordMap() in GameBoardDisplayer.java
	 * according to such assign rules exactly 6 cells would be connected to each other
	 * if a cell is with an id n, then it would connect to cell with id:
	 * 		(n - 1), (n + 1), (n - 1 - rowLen), (n + 1 - rowLen), (n - 1 + rowLen) and (n + 1 + rowLen)
	 * this method would check if the evaluated id is valid, i.e. the id should be in range [0, numberOfCells - 1]
	 * it also ensures that the resulting 
	 */
	public int[][] generateFullyConnectedAdjacencyMatrix()
	{
		int[][] mat = new int[numberOfCells][numberOfCells];
		int margin = (int)Math.ceil(Math.sqrt(numberOfCells)),rowLen = margin;
		for(int i = 0; i < mat.length; i++)
		{
				
				if( i != 0 && (i % margin) != 0 && (i % margin) != margin - 1)
				{
//					//not in margin, in upper column
					if(i % margin % 2 != 0)
					{
						int[] indicies = {i-1,i+1,i-rowLen,i+rowLen, i + rowLen -1, i + rowLen + 1};
						for(int ind : indicies)
						{
							if(ind >= 0 && ind < mat.length)
							{
									mat[i][ind] = 1;
									mat[ind][i] = 1;
							}
						}
					}else //not in margin, in lower column		
					{
						int[] indicies = {i-1,i+1,i-rowLen - 1,i-rowLen + 1,i-rowLen,i+rowLen};
						for(int ind : indicies)
						{
							if(ind >= 0 && ind < mat.length)
							{
									mat[i][ind] = 1;
									mat[ind][i] = 1;
							}
						}
					}
				}
				else
				{
//					//left margin
					if(i == 0 || i % margin == 0)
					{
						int[] indicies = {i+1,i - rowLen, i + rowLen, i - rowLen + 1};
						for(int ind : indicies)
						{
							if(ind >= 0 && ind < mat.length)
							{
									mat[i][ind] = 1;
									mat[ind][i] = 1;
							}
						}
					}else // right margin
					{
						int [] indicies = {i-1, i - rowLen, i+ rowLen,i + rowLen - 1};
						for(int ind : indicies)
						{
							if(ind >= 0 && ind < mat.length)
							{
									mat[i][ind] = 1;
									mat[ind][i] = 1;
							}
						}
					}
				}
		}
		return mat;
	}
	//determine if the graph of this game board is actually disconnected
	public boolean graphIsDisconnected()
	{
		int[][] mat = getAdjacencyMatrix();
		for(int i = 0; i < mat.length; i++)
		{
			if(sumDeg(mat,i) == 0)
				return true;
		}
		return false;
	}
	public ArrayList<Node> getNodes()
	{
		return nodes;
	};
	public ArrayList<Integer> getLargeCellsList()
	{
		return largeCells;
	}
	public GameBoard(int numCells)
	{
		numberOfCells = numCells;
		nodes = new ArrayList<Node>();
		largeCells = new ArrayList<Integer>();
		Random random = new Random();
		
		for(int i = 0; i < numCells; i++)
		{
			nodes.add(new Node());
			if(random.nextFloat() < LARGE_CELL_RATIO) // generate large cells with 1/4 probability
			{
				largeCells.add(i);
			}
		}
		//randomize Game board
		int[][] mat = this.generateRandomAdjacencyMatrix();
		connectNodesAccordingToAdjacencyMatrix(mat);
	}

}
